# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT

from __future__ import annotations

from typing import Annotated, Callable, Literal, Optional, Type, overload

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import Field


class FailoverIpSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FailoverIpSpec"]:
            return FailoverIpSpec

        def build(self) -> "FailoverIpSpec":
            return FailoverIpSpec(**self._attrs)

        def ip(self, value: str, /) -> Self:
            return self._set("ip", value)

        def secret_name(self, value: str, /) -> Self:
            return self._set("secret_name", value)

    class BuilderContext(BuilderContextBase["FailoverIpSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FailoverIpSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FailoverIpSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FailoverIpSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FailoverIpSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ip: str
    secret_name: Annotated[str, Field(alias="secretName")]


class FailoverIpStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FailoverIpStatus"]:
            return FailoverIpStatus

        def build(self) -> "FailoverIpStatus":
            return FailoverIpStatus(**self._attrs)

        def assigned_node(self, value: Optional[str], /) -> Self:
            return self._set("assigned_node", value)

        def desired_node(self, value: Optional[str], /) -> Self:
            return self._set("desired_node", value)

        def last_sync_attempt(self, value: Optional[str], /) -> Self:
            return self._set("last_sync_attempt", value)

        def last_sync_success(self, value: Optional[str], /) -> Self:
            return self._set("last_sync_success", value)

    class BuilderContext(BuilderContextBase["FailoverIpStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FailoverIpStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FailoverIpStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FailoverIpStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FailoverIpStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    assigned_node: Annotated[Optional[str], Field(alias="assignedNode")] = None
    desired_node: Annotated[Optional[str], Field(alias="desiredNode")] = None
    last_sync_attempt: Annotated[Optional[str], Field(alias="lastSyncAttempt")] = None
    last_sync_success: Annotated[Optional[str], Field(alias="lastSyncSuccess")] = None


class FailoverIp(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FailoverIp"]:
            return FailoverIp

        def build(self) -> "FailoverIp":
            return FailoverIp(**self._attrs)

        @overload
        def spec(self, value_or_callback: FailoverIpSpec, /) -> "FailoverIp.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [FailoverIpSpec.Builder], FailoverIpSpec.Builder | FailoverIpSpec
            ],
            /,
        ) -> "FailoverIp.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "FailoverIpSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = FailoverIpSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FailoverIpSpec.builder())
                if isinstance(output, FailoverIpSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[FailoverIpStatus], /
        ) -> "FailoverIp.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [FailoverIpStatus.Builder], FailoverIpStatus.Builder | FailoverIpStatus
            ],
            /,
        ) -> "FailoverIp.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "FailoverIpStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = FailoverIpStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FailoverIpStatus.builder())
                if isinstance(output, FailoverIpStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["netcup.noshoes.xyz/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["FailoverIp"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "FailoverIp.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "FailoverIp.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["FailoverIp.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FailoverIp.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FailoverIp."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FailoverIp", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FailoverIp.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: FailoverIpSpec
    status: Optional[FailoverIpStatus] = None
    api_version: Annotated[
        Optional[Literal["netcup.noshoes.xyz/v1"]], Field(alias="apiVersion")
    ] = "netcup.noshoes.xyz/v1"
    kind: Optional[Literal["FailoverIp"]] = "FailoverIp"
    metadata: Optional[apimachinery.ObjectMeta] = None
